#include "StdAfx.h"
#include "Compiler.h"

bool CCompiler::CompileCS(const char* pszFile)
{
    if(false == m_oParser.Parse(pszFile))
    {
        m_strErrMsg = m_oParser.m_strErrMsg;
        return false;
    }

    size_t i;
    for(i = 0; i < m_oParser.m_oVecTableInfo.size(); i++)
    {
        CTableClassInfo oClassInfo;
        if(false == _CompileClassInfo(m_oParser.m_oVecTableInfo[i], oClassInfo))
        {
            return false;
        }

        m_oVecTableClassInfo.push_back(oClassInfo);
    }

    for(i = 0; i < m_oParser.m_oVecTableInfo.size(); i++)
    {
		if(m_oVecTableClassInfo[i].m_bServerOnly) {
			continue;
		}

        if(false == _WriteTblCSFile(m_oVecTableClassInfo[i]))
        {
            return false;
        }
    }

    if(false == _WriteTableMgrFileCS())
    {
        return false;
    }

    m_strErrMsg.Format("Compile %s OK", pszFile);
    return true;
}

bool CCompiler::_WriteTblCSFile(CTableClassInfo& roClassInfo)
{
    CString strCSFile;
    CString strCSNameSpcae;
    CString strCStruct;
    size_t i;
    strCStruct.Format("Struc%s",roClassInfo.m_strClassName);
    strCSNameSpcae.Format("Tableload");
    strCSFile.Format("%s\\%s", m_strOutputPath, roClassInfo.m_strCSFile);
    FILE* fp = fopen(strCSFile, "w");
    if(NULL == fp)
    {
        m_strErrMsg.Format("open file %s for write failed", roClassInfo.m_strCSFile);
        return false;
    }

    fprintf(fp, 
        "/********************************************************************\n"
        "**       This head file is generated by program,                   **\n"
        "**            Please do not change it directly.                    **\n"
        "********************************************************************/\n"
        "\n");

    fprintf(fp, 
        "using System;\n"
		"using TSSGClient;\n"
        "using UnityEngine;\n"
        "using System.Collections.Generic;\n"
        "using System.Text;\n"
        "using System.IO;\n"
        "using System.Collections;\n"
        "using INT8 = System.SByte;\n"
        "using UINT8 = System.Byte;\n"
        "using UINT16 = System.UInt16;\n"
        "using INT16 = System.Int16;\n"
        "using INT32 = System.Int32;\n"
        "using UINT32 = System.UInt32;\n"
        "using INT64 = System.Int64;\n"
        "using UINT64 = System.UInt64;\n"
        "\n\n"
        "namespace %s\n"
        "{\n",
        strCSNameSpcae);
    fprintf(fp,
        "\tpublic class %s\n"
        "\t{\n",
        strCStruct);
    for(i = 0; i < roClassInfo.m_oVecItems.size(); i++)
    {
        if(DATATYPE_COMMENT == roClassInfo.m_oVecItems[i].m_nDataType)
        {
            roClassInfo.m_oVecItems[i].m_strMemberType = "string";
        }
        
        fprintf(fp, "    \tpublic %s m_%s;\n", roClassInfo.m_oVecItems[i].m_strMemberType, roClassInfo.m_oVecItems[i].m_strMemberName);
    }
    fprintf(fp,
    "\t}\n\n");
    fprintf(fp,
        "\tpublic class %s\n"
        "\t{\n"
        "    \tpublic static string m_strFile = \"%s\";\n"
        "    \tpublic static INT32 m_nColCount = %d;\n",
        roClassInfo.m_strClassName,
        roClassInfo.m_strTblFile,
        roClassInfo.m_oVecItems.size());

    if(false == roClassInfo.m_strTblFile.IsEmpty())
    {
        if(KEY_MODE_SET == roClassInfo.m_nKeyMode)
        {
             fprintf(fp, "\t\tpublic Dictionary<%s,List<%s>> m_h%s = new Dictionary<%s,List<%s>>();\n",
                 roClassInfo.m_strKeyType, strCStruct, roClassInfo.m_strName, roClassInfo.m_strKeyType, strCStruct);
        } else if(KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode)
        {
            fprintf(fp, "\t\tpublic Dictionary<UINT64,List<%s>> m_h%s = new Dictionary<UINT64,List<%s>>();\n", strCStruct, roClassInfo.m_strName, strCStruct);
        } else
            fprintf(fp, "\t\tpublic Dictionary<%s,%s> m_h%s = new Dictionary<%s,%s>();\n",
                roClassInfo.m_strKeyType, strCStruct, roClassInfo.m_strName, roClassInfo.m_strKeyType, strCStruct);
    }

    if(KEY_MODE_SET == roClassInfo.m_nKeyMode )
    {
        fprintf(fp, "\t\tpublic static INT32 m_%sLastKey = 0;\n", roClassInfo.m_strKeyPrefix);
    }
    if(KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode)
    {
        fprintf(fp, "\t\tpublic static UINT64 m_%sLastKey = 0;\n", roClassInfo.m_strKeyPrefix);
        fprintf(fp, "\t\tpublic static %s m_%sLastKey1 = 0;\n", roClassInfo.m_strKeyType,roClassInfo.m_strKeyPrefix);
        fprintf(fp, "\t\tpublic static %s m_%sLastKey2 = 0;\n", roClassInfo.m_strKey2Type,roClassInfo.m_strKeyPrefix);
    }

    fprintf(fp,
        "\t\tpublic bool LoadFromFile(string path = \"\", AssetBundle bundle = null, string language = \"zh-Hans\")\n"
        "\t\t{\n"
        //"    \t\tif((object)pszFile != null)\n"
        //"    \t\t{\n"
        //"        \t\tm_strFile = pszFile;\n"
        //"    \t\t}\n\n"
        "    \t\tm_h%s.Clear();\n"
        "    \t\tList<string> oVecLines = new List<string>();\n"
		"	 \t\tstring filename = m_strFile.Substring(9).Replace(\"$language$\", language);\n"
		"	 \t\tbyte[] textBytes = null;\n"
		"	 \t\tif(bundle != null)\n"
		"	 \t\t{\n"
		"	 \t\t\tTextAsset oTextAsset = null;\n"
		"	 \t\t\toTextAsset = bundle.Load(filename + \".txt\") as TextAsset;\n"
		"	 \t\t\ttextBytes = oTextAsset.bytes;\n"
		"	 \t\t}\n"
		"	 \t\telse if(path != \"\")\n"
		"	 \t\t{\n"
		"	 \t\t\tWWW tableLoder = new WWW(path + filename + \".txt\");\n"
		"	 \t\t\twhile (!tableLoder.isDone) { };\n"
		"	 \t\t\ttextBytes = tableLoder.bytes;\n"
		"	 \t\t}\n"
		"	 \t\telse\n"
		"	 \t\t{\n"
		"	 \t\t\tTextAsset oTextAsset = Resources.Load(m_strFile) as TextAsset;\n"
		"	 \t\t\ttextBytes = oTextAsset.bytes;\n"
		"	 \t\t}\n"
        "    \t\tStream s = new MemoryStream(textBytes);\n"
        "    \t\tStreamReader sr = new StreamReader(s);\n"
        "    \t\tstring strLine;\n"
        "    \t\tstrLine = sr.ReadLine();\n"
        "    \t\toVecLines.Add(strLine);\n"
        "    \t\twhile (strLine != null)\n"
        "    \t\t{\n"
        "        \t\tstrLine = sr.ReadLine();\n"
        "        \t\toVecLines.Add(strLine);\n"
        "    \t\t}"
        "\n"
        "    \t\tsr.Close();\n"
//        "    \t\tList<string> oHeaders =new List<string>();\n"
        "    \t\tstring[] sHeaders = oVecLines[1].Split(new char[]{'\\t'}); \n"
        "    \t\t"
        "\n"
        "    \t\tif(sHeaders.Length != m_nColCount)\n"
        "    \t\t{\n"
        "        \t\treturn false;\n"
        "    \t\t}\n"
        "\n"
        "    \t\tINT32[] anIndex = new INT32[%d];\n"
        "    \t\tUINT32 i;\n"
        "    \t\tfor(i = 0; i < %d; i++)\n"
        "    \t\t{\n"
        "        \t\tanIndex[i] = -1;\n"
        "    \t\t}\n"
        "\n"
        "    \t\tfor(i = 0; i < %d; i++)\n"
        "    \t\t{\n",
        roClassInfo.m_strName,
        roClassInfo.m_oVecItems.size(),
        roClassInfo.m_oVecItems.size(),
        roClassInfo.m_oVecItems.size());

    
    for(i = 0; i < roClassInfo.m_oVecItems.size(); i++)
    {
        if(0 == i)
        {
            fprintf(fp,
                "        \t\tif(sHeaders[i] == \"%s\")\n"
                "        \t\t{\n"
                "            \t\tanIndex[%d] = (INT32)i;\n"
                "        \t\t}\n",
                roClassInfo.m_oVecItems[i].m_strRawName,
                i);
        }
        else
        {
            fprintf(fp,
                "        \t\telse if(sHeaders[i] == \"%s\")\n"
                "        \t\t{\n"
                "            \t\tanIndex[%d] = (INT32)i;\n"
                "        \t\t}\n",
                roClassInfo.m_oVecItems[i].m_strRawName,
                i);
        }
    }

    fprintf(fp,
        "        \t\telse\n"
        "        \t\t{\n" 
		"            \t\tDebugLog.LogError(string.Format(\"Load File {0} failed, header {1} is invalid\", m_strFile, sHeaders[i]));\n"
        "            \t\treturn false;\n"
        "        \t\t}\n"
        "    \t\t}\n\n");
        
    fprintf(fp, 
        "    \t\tfor(i = 0; i < %d; i++)\n"
        "    \t\t{\n"
        "        \t\tif(-1 == anIndex[i])\n"
        "        \t\t{\n"
		"            \t\tDebugLog.LogError(string.Format(\"Load File {0} failed, not find all headers\", m_strFile));\n"
        "            \t\treturn false;\n"
        "        \t\t}\n"
        "    \t\t}\n\n",
        roClassInfo.m_oVecItems.size());

    fprintf(fp,
        "    \t\tfor(i = 2; i < oVecLines.Count-1; i++)\n"
        "    \t\t{\n"
        "        \t\tstring[] sHeader = oVecLines[(INT32)i].Split(new char[]{'\\t'}); \n"

        "\n"
        "        \t\t%s oItem = new %s();\n",strCStruct,strCStruct);
    fprintf(fp,
        "        \t\tif (sHeader[anIndex[0]].Length>0)\n"
        "        \t\t{\n"
        "            \t\toItem.m_%s = (INT32)int.Parse(sHeader[anIndex[0]]);\n"
        "        \t\t}\n"
        "        \t\telse\n"
        "            \t\toItem.m_%s = 0;\n\n",
        roClassInfo.m_oVecItems[0].m_strMemberName,roClassInfo.m_oVecItems[0].m_strMemberName); 
        size_t Limit = 1;  
    if(KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode){
    fprintf(fp,
        "        \t\tif (sHeader[anIndex[1]].Length>0)\n"
        "        \t\t{\n"
        "            \t\toItem.m_%s = (INT32)int.Parse(sHeader[anIndex[1]]);\n"
        "        \t\t}\n"
        "        \t\telse\n"
        "            \t\toItem.m_%s = 0;\n\n",
        roClassInfo.m_oVecItems[1].m_strMemberName,roClassInfo.m_oVecItems[1].m_strMemberName);   
//     fprintf(fp,
//         "        \t\tif (sHeader[anIndex[2]].Length>0)\n"
//         "        \t\t{\n"
//         "            \t\toItem.m_%s = (INT32)int.Parse(sHeader[anIndex[2]]);\n"
//         "        \t\t}\n"
//         "        \t\telse\n"
//         "            \t\toItem.m_%s = 0;\n\n",
//         roClassInfo.m_oVecItems[2].m_strMemberName,roClassInfo.m_oVecItems[2].m_strMemberName);   
        Limit = 2; 
    }

    for(i =Limit; i < roClassInfo.m_oVecItems.size(); i++)
    {
            
        if(DATATYPE_COMMENT == roClassInfo.m_oVecItems[i].m_nDataType)
        {
            fprintf(fp, 
                "        \t\tif(sHeaders.Length > anIndex[%d])\n"
                "        \t\t{\n"
                "            \t\toItem.m_%s = sHeader[anIndex[%d]];\n"
                "        \t\t}\n",
                i,
                roClassInfo.m_oVecItems[i].m_strMemberName,i);
        }
        else if(DATATYPE_STRING == roClassInfo.m_oVecItems[i].m_nDataType)
        {
            fprintf(fp, 
                "        \t\tif(sHeaders.Length > anIndex[%d])\n"
                "        \t\t{\n"
                "            \t\toItem.m_%s = sHeader[anIndex[%d]];\n"
                "        \t\t}\n",
                i,
                roClassInfo.m_oVecItems[i].m_strMemberName,i);
        }
        else if(DATATYPE_DOUBLE == roClassInfo.m_oVecItems[i].m_nDataType)
        {
            fprintf(fp,
				"        \t\tif(sHeader[anIndex[%d]].Length > 0)\n"
                "        \t\t\toItem.m_%s = (%s)float.Parse(sHeader[anIndex[%d]]);\n"
				"        \t\telse\n"
				"        \t\t\toItem.m_%s = 0;\n",
                i, roClassInfo.m_oVecItems[i].m_strMemberName,roClassInfo.m_oVecItems[i].m_strMemberType, i, roClassInfo.m_oVecItems[i].m_strMemberName);
        }
        else
        {
			fprintf(fp,
				"        \t\tif(sHeader[anIndex[%d]].Length > 0)\n"
				"        \t\t\toItem.m_%s = (%s)int.Parse(sHeader[anIndex[%d]]);\n"
				"        \t\telse\n"
				"        \t\t\toItem.m_%s = 0;\n",
				i, roClassInfo.m_oVecItems[i].m_strMemberName,roClassInfo.m_oVecItems[i].m_strMemberType, i, roClassInfo.m_oVecItems[i].m_strMemberName);
        }
    }
    

    if(KEY_MODE_MULITI == roClassInfo.m_nKeyMode || KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode )
    {
        fprintf(fp,
            "\n"
            "        \t\tif(false == _AddItem(oItem.m_%s, oItem.m_%s, oItem))\n",
            roClassInfo.m_strKeyName, roClassInfo.m_strKey2Name);
    }
    else
    {
        fprintf(fp,
            "\n"
            "        \t\tif(false == _AddItem(oItem.m_%s,oItem))\n",
            roClassInfo.m_strKeyName);
    }

    fprintf(fp,
        "        \t\t{\n"
        "            \t\treturn false;\n"
        "        \t\t}\n"
        "    \t\t}\n"
        "\t\t\n");
        
   fprintf(fp,
//	   "	\t\tResources.UnloadAsset(oTextAsset);\n"
	   "    \t\tDebugLog.Log(string.Format(\"Load File{0} ok, {1} lines, {2} cols\", m_strFile, oVecLines.Count, m_nColCount));\n"
       "    \t\treturn true;\n"
       "\t\t}\n\n"
       );
    if(KEY_MODE_MULITI == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic %s Get(%s %s, %s %s)\n"
            "\t\t{\n"
            "    \t\tUINT64 qwKey = (UINT64)%s;\n"
            "    \t\tqwKey = (qwKey << 32) | (UINT64)%s;\n"
            "    \t\tforeach (DictionaryEntry ID in m_h%s)\n"
            "    \t\tfor (INT32 i = 0; i < m_h%s.Count; ++i)\n"
            "    \t\t{\n"
            "        \t\tif((UINT64)ID.Key == qwKey )\n"
            "            \t\treturn (%s)ID.Value;\n"
            "    \t\t}\n"
            "    \t\treturn null;\n"
            "\t\t}\n\n",
            strCStruct,roClassInfo.m_strKeyType, roClassInfo.m_strKeyName, roClassInfo.m_strKey2Type, roClassInfo.m_strKey2Name,
            roClassInfo.m_strKeyName,
            roClassInfo.m_strKey2Name,
            roClassInfo.m_strName,strCStruct);
    }
    else if(KEY_MODE_SET == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic List<%s> Get(%s %s)\n"
            "\t\t{\n"
            "    \t\tif (m_h%s.ContainsKey(%s))\n"
            "        \t\treturn m_h%s[%s];\n"
            "    \t\treturn null;\n"
            "\t\t}\n\n",
            strCStruct, roClassInfo.m_strKeyType, roClassInfo.m_strKeyName,
            roClassInfo.m_strName,roClassInfo.m_strKeyName,
            roClassInfo.m_strName,roClassInfo.m_strKeyName);
    }
    else if(KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic List<%s> Get(%s %s, %s %s)\n"
            "\t\t{\n"
            "    \t\tUINT64 qwKey = (UINT64)%s;\n"
            "    \t\tqwKey = (qwKey << 32) | (UINT64)%s;\n"

            "    \t\tif (m_h%s.ContainsKey(qwKey))\n"
            "        \t\treturn m_h%s[qwKey];\n"
            "    \t\treturn null;\n"
            "\t\t}\n\n",
            strCStruct,roClassInfo.m_strKeyType, roClassInfo.m_strKeyName, roClassInfo.m_strKey2Type, roClassInfo.m_strKey2Name,
            roClassInfo.m_strKeyName,
            roClassInfo.m_strKey2Name,
            roClassInfo.m_strName,
            roClassInfo.m_strName);
    }
    else
    {
            fprintf(fp,
                "\t\tpublic %s Get(%s %s)\n"
                "\t\t{\n"
                "    \t\tif (m_h%s.ContainsKey(%s))\n"
                "        \t\treturn m_h%s[%s];\n"
                "    \t\treturn null;\n"
                "\t\t}\n\n",
                strCStruct,roClassInfo.m_strKeyType, roClassInfo.m_strKeyName,
                roClassInfo.m_strName,roClassInfo.m_strKeyName,
                roClassInfo.m_strName,roClassInfo.m_strKeyName);
    }

    if(KEY_MODE_MULITI == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic bool _AddItem(%s %s, %s %s, %s poItem)\n"
            "\t\t{\n"
            "    \t\tUINT64 qwKey = (UINT64)%s;\n"
            "    \t\tqwKey = (qwKey << 32) | (UINT64)%s;\n"
            "    \t\tif((object)Get(%s, %s) != null)\n"
            "    \t\t{\n"
            "        \t\treturn false;\n"
            "    \t\t}\n"
            "\n"
            "    \t\tm_h%s.Add(qwKey, poItem);\n"
            "    \t\treturn true;"
            "}\n\n",
            roClassInfo.m_strKeyType, roClassInfo.m_strKeyName, roClassInfo.m_strKey2Type, roClassInfo.m_strKey2Name,strCStruct,
            roClassInfo.m_strKeyName,
            roClassInfo.m_strKey2Name,
            roClassInfo.m_strKeyName, roClassInfo.m_strKey2Name,roClassInfo.m_strName);
    }
    else if(KEY_MODE_SET == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic bool _AddItem(%s %s, %s poItem)\n"     //1
            "\t\t{\n"
            "    \t\tif(0 == %s)\n"     //2
            "    \t\t{\n"
            "        \t\t%s = m_%sLastKey;\n" //3    
            "        \t\tif(0 == %s)\n"     //4
            "        \t\t{\n"
			"            \t\tDebugLog.LogError(string.Format(\"Load File {0} failed, key of first row is null\", m_strFile));\n"
            "           \t\t return false;\n"
            "        \t\t}\n"
            "        \t\tpoItem.m_%s = %s;\n"      //4.1
            "        \t\tGet(%s).Add(poItem);\n"    //4.2
            "        \t\treturn true;\n"
            "    \t\t}\n\n"
            "    \t\tif(Get(%s) != null)\n" 
            "    \t\t{\n"
            "        \t\treturn false;\n"
            "    \t\t}\n"
            "\n"
            "    \t\tList<%s> oVecItem = new List<%s>();\n"
            "    \t\toVecItem.Add(poItem);\n"
            "    \t\tm_h%s.Add(%s,oVecItem);\n"  //7
            "    \t\tm_%sLastKey = %s;\n"   //8
            "    \t\treturn true;\n"
            "\t\t}\n\n",
            roClassInfo.m_strKeyType, roClassInfo.m_strKeyName,strCStruct,     //1
            roClassInfo.m_strKeyName,   //2
            roClassInfo.m_strKeyName, roClassInfo.m_strKeyPrefix,   //3
            roClassInfo.m_strKeyName,   //4
            roClassInfo.m_strKeyName, roClassInfo.m_strKeyName, //4.1
            roClassInfo.m_strKeyName, //4.2
            roClassInfo.m_strKeyName,   //5
            strCStruct,strCStruct,
            roClassInfo.m_strName,roClassInfo.m_strKeyName,    //7
            roClassInfo.m_strKeyPrefix, roClassInfo.m_strKeyName);
    }
    else if(KEY_MODE_MULITI_SET == roClassInfo.m_nKeyMode)
    {
        fprintf(fp,
            "\t\tpublic bool _AddItem(%s %s,%s %s, %s poItem)\n"    //1 
            "\t\t{\n"
            "    \t\tUINT64 qwKey = (UINT64)%s;\n"//2
            "    \t\tqwKey = (qwKey << 32) | (UINT64)%s;\n"//3
            "    \t\tif(0 == qwKey)\n"     
            "    \t\t{\n"
            "        \t\tqwKey = m_%sLastKey;\n"    //4
            "        \t\tif(0 == qwKey)\n"     
            "        \t\t{\n"
			"            \t\tDebugLog.LogError(string.Format(\"Load File {0} failed, key of first row is null\", m_strFile));\n"
            "           \t\t return false;\n"
            "        \t\t}\n"
            "        \t\tpoItem.m_%s = %s;\n"      //5
            "        \t\tpoItem.m_%s = %s;\n"      //5.1
            "        \t\tGet(m_%sLastKey1,m_%sLastKey2).Add(poItem);\n"    //6
            "        \t\treturn true;\n"
            "    \t\t}\n\n"
            "    \t\tif(Get(%s ,%s) != null)\n" //7
            "    \t\t{\n"
            "        \t\treturn false;\n"
            "    \t\t}\n"
            "\n"
            "    \t\tList<%s> oVecItem = new List<%s>();\n" //7.1
            "    \t\toVecItem.Add(poItem);\n"
            "    \t\tm_h%s.Add(qwKey,oVecItem);\n"  //7.2
            "    \t\tm_%sLastKey = qwKey;\n"   //8
            "    \t\tm_%sLastKey1 = %s;\n"   //8.1
            "    \t\tm_%sLastKey2 = %s;\n"   //8.2
            "    \t\treturn true;\n"
            "\t\t}\n\n",
            roClassInfo.m_strKeyType, roClassInfo.m_strKeyName,roClassInfo.m_strKey2Type, roClassInfo.m_strKey2Name,strCStruct,     //1
            roClassInfo.m_strKeyName,//2
            roClassInfo.m_strKey2Name,//3
            roClassInfo.m_strKeyPrefix,   //4
            roClassInfo.m_strKeyName, roClassInfo.m_strKeyName,//5
            roClassInfo.m_strKey2Name, roClassInfo.m_strKey2Name,//5.1
            roClassInfo.m_strKeyPrefix,roClassInfo.m_strKeyPrefix,//6
            roClassInfo.m_strKeyName,  roClassInfo.m_strKey2Name, //7
            strCStruct,strCStruct,//7.1
            roClassInfo.m_strName,    //7.2
            roClassInfo.m_strKeyPrefix,
            roClassInfo.m_strKeyPrefix,roClassInfo.m_strKeyName,
            roClassInfo.m_strKeyPrefix,roClassInfo.m_strKey2Name
            );
    }
    else
    {
        fprintf(fp,
            "\t\tpublic bool _AddItem(%s %s,%s poItem)\n"
            "\t\t{\n"
            "    \t\tif((object)Get(%s) != null)\n"
            "    \t\t{\n"
			"        \t\tDebugLog.LogError(string.Format(\"Load File {0} failed, %s {1} repeat\", m_strFile, (UINT32)%s));\n"
            "        \t\treturn false;\n"
            "    \t\t}\n"
            "\n"
            "    \t\tm_h%s.Add(%s, poItem);\n"
            "    \t\treturn true;\n"
            "\t\t}\n"
            "\n",
             roClassInfo.m_strKeyType, roClassInfo.m_strKeyName,strCStruct,
            roClassInfo.m_strKeyName,
            roClassInfo.m_strKeyName, roClassInfo.m_strKeyName,
            roClassInfo.m_strName,roClassInfo.m_strKeyName);
    }
    fprintf(fp,"\t}\n}\n");

    fclose(fp);
    return true;
}

bool CCompiler::_WriteTableMgrFileCS()
{
    CString strCSFile;
    strCSFile.Format("%s\\tablemgr.CS", m_strOutputPath);
    size_t i;
        
    FILE* fp = fopen(strCSFile, "w");
    if(NULL == fp)
    {
        m_strErrMsg.Format("open file %s for write failed", strCSFile);
        return false;
    }
    fprintf(fp, 
        "/********************************************************************\n"
        "**       This head file is generated by program,                   **\n"
        "**            Please do not change it directly.                    **\n"
        "********************************************************************/\n"
        "\n");
    fprintf(fp,"using System;\nusing TSSGClient;\nusing Tableload;using UnityEngine;\n\n\n ");
    
    fprintf(fp,"public class tablemgr\n"
    "{\n");
    fprintf(fp,"\tprivate static tablemgr m_instance = null;\n");
    for(i = 0; i < m_oVecTableClassInfo.size(); i++)
    {
		if(m_oVecTableClassInfo[i].m_bServerOnly) {
			continue;
		}
        if(false == m_oVecTableClassInfo[i].m_strTblFile.IsEmpty())
        {
            fprintf(fp,"\tpublic C%s g_o%s = new C%s();\n",m_oVecTableClassInfo[i].m_strName,m_oVecTableClassInfo[i].m_strName,m_oVecTableClassInfo[i].m_strName);
        }
    }
    fprintf(fp,
    "\tpublic tablemgr ()\n"    
    "\t{\n\t}\n\n");
    
    fprintf(fp,
        "\tpublic static tablemgr Instance {\n"    
        "\t\tget {\n"
        "\t\t\tif (m_instance == null)\n"
        "\t\t\t{\n"
        "\t\t\t\tm_instance = new tablemgr();\n"
        "\t\t\t}\n"
        "\n\t\t\treturn m_instance;\n"
        "\t\t}\n"
        "\t}\n");

	fprintf(fp,
		"\tpublic static void empty()\n"
		"\t{\n");
	fprintf(fp,
		"\t\t m_instance = null; \n"
		"\t}\n");

    fprintf(fp,
    "\tpublic bool LoadAllTables(string path = \"\", AssetBundle bundle = null, string language = \"zh-Hans\")\n"
    "\t{\n");
    for(i = 0; i < m_oVecTableClassInfo.size(); i++)
    {
		if(m_oVecTableClassInfo[i].m_bClientSkipLoad)
        {
            fprintf(fp,
                "    \tif(!Application.isPlaying || Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor)\n"
                "    \t{\n");
        }

        if(false == m_oVecTableClassInfo[i].m_strTblFile.IsEmpty() &&
			false == m_oVecTableClassInfo[i].m_bServerOnly)
        {
            fprintf(fp, 
                "    \tif(false == g_o%s.LoadFromFile(path, bundle, language))\n"
                "    \t{\n"
                "    \t\tDebugLog.LogError(\"Read %s Tabel Error!\");\n"
                "        \treturn false;\n\n"
                "    \t}\n",
                m_oVecTableClassInfo[i].m_strName, m_oVecTableClassInfo[i].m_strName);
        }
        if (m_oVecTableClassInfo[i].m_bClientSkipLoad)
        {
            fprintf(fp,"    \t}\n");
        }
    }
    fprintf(fp, 
        "    \treturn true;\n"
        "\t}\n"
        "}\n");
	fclose(fp);

    return true;
}