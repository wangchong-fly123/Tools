#include "StdAfx.h"
#include "PropCompiler.h"
#include "markupstl.h"


CPropCompiler::CPropCompiler(void)
{
}

CPropCompiler::~CPropCompiler(void)
{
}

bool CPropCompiler::Parse(const char* pszFile)
{
    CMarkupSTL oXml;
    if(false == oXml.Load(pszFile))
    {
        m_strErrMsg.Format("Load %s failed, %s", pszFile, oXml.GetError().c_str());
        return false;
    }

    if(false == oXml.FindElem("props"))
    {
        m_strErrMsg.Format("file %s, Can not find elem props", pszFile);
        return false;
    }

    if(false == oXml.IntoElem())
    {
        m_strErrMsg.Format("file %s, can not into elem props", pszFile);
        return false;
    }

    while(oXml.FindElem("prop"))
    {
        SPropInfo stProp;
        string strVal = oXml.GetAttrib("id");
        if(strVal.empty())
        {
            m_strErrMsg.Format("file %s, can not find id in prop", pszFile);
            return false;
        }

        stProp.m_strID = strVal;

        strVal = oXml.GetAttrib("type");
        if(strVal == "INT32")
        {
            stProp.m_nType = PROPTYPE_INT32;
        }
        else if(strVal == "double")
        {
            stProp.m_nType = PROPTYPE_DOUBLE;
        }
        else
        {
            m_strErrMsg.Format("file %s, id %s, type is invalid", pszFile, stProp.m_strID.c_str());
            return false;
        }

        stProp.m_strMin = oXml.GetAttrib("min");
        stProp.m_strMax = oXml.GetAttrib("max");

        m_oVecProps.push_back(stProp);
    }

    return true;
}

bool CPropCompiler::Compile(const char* pszDir)
{
    CString strPropXml;
    strPropXml.Format("%s\\prop.xml", pszDir);

    if(false == Parse(strPropXml))
    {
        return false;
    }

    CString strUnitIncFile;
    strUnitIncFile.Format("%s\\unitinc.h", pszDir);
    if(false == CompileUnitInc(strUnitIncFile))
    {
        return false;
    }

    CString strUnitPropBagInc;
    strUnitPropBagInc.Format("%s\\unitpropbaginc.h", pszDir);
    if(false == CompileUnitPropBagInc(strUnitPropBagInc))
    {
        return false;
    }

    CString strPropCode;
    strPropCode.Format("%s\\propcode.cpp", pszDir);
    if(false == CompilePropCode(strPropCode))
    {
        return false;
    }

    return true;
}

bool CPropCompiler::CompileUnitInc(const char* pszFile)
{
    FILE* fp = fopen(pszFile, "w");
    if(NULL == fp)
    {
        m_strErrMsg.Format("open %s for write failed", pszFile);
        return false;
    }

    fprintf(fp, 
        "/********************************************************************\n"
        "**       This head file is generated by program,                   **\n"
        "**            Please do not change it directly.                    **\n"
        "********************************************************************/\n"
        "\n");

    for(size_t i = 0; i < m_oVecProps.size(); i++)
    {
        SPropInfo& rstProp = m_oVecProps[i];
        CString strType;

        if(PROPTYPE_INT32 == rstProp.m_nType)
        {
            strType = "INT32";
        }
        else
        {
            strType = "double";
        }

        fprintf(fp, "virtual %s Get%s()\n{\n", strType, rstProp.m_strID.c_str());

        if(false == rstProp.m_strMax.empty())
        {
            fprintf(fp,
                "    if(m_oUnigPropBag.m_o%s.GetValue() > %s)\n"
                "    {\n"
                "        return %s;\n"
                "    }\n",
                rstProp.m_strID.c_str(), rstProp.m_strMax.c_str(),
                rstProp.m_strMax.c_str());
        }
        if(false == rstProp.m_strMin.empty())
        {
            fprintf(fp,
                "    if(m_oUnigPropBag.m_o%s.GetValue() < %s)\n"
                "    {\n"
                "        return %s;\n"
                "    }\n",
                rstProp.m_strID.c_str(), rstProp.m_strMin.c_str(),
                rstProp.m_strMin.c_str());
        }

        fprintf(fp, 
            "    return m_oUnigPropBag.m_o%s.GetValue();\n"
            "}\n\n",
            rstProp.m_strID.c_str());
    }

    fclose(fp);
    
    return true;
}

bool CPropCompiler::CompileUnitPropBagInc(const char* pszFile)
{
    FILE* fp = fopen(pszFile, "w");
    if(NULL == fp)
    {
        m_strErrMsg.Format("open %s for write failed", pszFile);
        return false;
    }

    fprintf(fp, 
        "/********************************************************************\n"
        "**       This head file is generated by program,                   **\n"
        "**            Please do not change it directly.                    **\n"
        "********************************************************************/\n"
        "\n");

    for(size_t i = 0; i < m_oVecProps.size(); i++)
    {
        SPropInfo& rstProp = m_oVecProps[i];
        CString strType;

        if(PROPTYPE_INT32 == rstProp.m_nType)
        {
            strType = "CInt32Prop";
        }
        else
        {
            strType = "CDoubleProp";
        }

        fprintf(fp, "%s m_o%s;\n", strType, rstProp.m_strID.c_str());

    }

    fclose(fp);

    return true;
}

bool CPropCompiler::CompilePropCode(const char* pszFile)
{
    FILE* fp = fopen(pszFile, "w");
    if(NULL == fp)
    {
        m_strErrMsg.Format("open %s for write failed", pszFile);
        return false;
    }

    fprintf(fp, 
        "/********************************************************************\n"
        "**       This head file is generated by program,                   **\n"
        "**            Please do not change it directly.                    **\n"
        "********************************************************************/\n"
        "\n"
        "#include \"gamepch.h\"\n"
        "#include \"unit.h\"\n\n");

    fprintf(fp, 
        "void CUnitPropBag::Reset()\n"
        "{\n");

    size_t i;
    for(i = 0; i < m_oVecProps.size(); i++)
    {
        fprintf(fp, "    m_o%s.Reset();\n", m_oVecProps[i].m_strID.c_str());
    }

    fprintf(fp, "}\n\n");


    fprintf(fp, 
        "CInt32Prop* CUnitPropBag::GetInt32Prop(UINT16 wPropID)\n"
        "{\n"
        "    if(wPropID > GMPROP_SumStart)\n"
        "    {\n"
        "        wPropID -= GMPROP_SumStart;\n"
        "    }\n"
        "    else if(wPropID > GMPROP_RateStart)\n"
        "    {\n"
        "        wPropID -= GMPROP_RateStart;\n"
        "    }\n"
        "\n"
        "    switch(wPropID)\n"
        "    {\n");

    for(i = 0; i < m_oVecProps.size(); i++)
    {
        SPropInfo& rstProp = m_oVecProps[i];
        if(rstProp.m_nType != PROPTYPE_INT32)
        {
            continue;
        }

        fprintf(fp, 
            "    case GMPROP_%s:\n"
            "        return &m_o%s;\n",
            rstProp.m_strID.c_str(),
            rstProp.m_strID.c_str());
    }

    fprintf(fp, 
        "    default:\n"
        "        return NULL;\n"
        "    }\n"
        "}\n\n");

    fprintf(fp, 
        "CDoubleProp* CUnitPropBag::GetDoubleProp(UINT16 wPropID)\n"
        "{\n"
        "    if(wPropID > GMPROP_SumStart)\n"
        "    {\n"
        "        wPropID -= GMPROP_SumStart;\n"
        "    }\n"
        "    else if(wPropID > GMPROP_RateStart)\n"
        "    {\n"
        "        wPropID -= GMPROP_RateStart;\n"
        "    }\n"
        "\n"
        "    switch(wPropID)\n"
        "    {\n");

    for(i = 0; i < m_oVecProps.size(); i++)
    {
        SPropInfo& rstProp = m_oVecProps[i];
        if(rstProp.m_nType != PROPTYPE_DOUBLE)
        {
            continue;
        }

        fprintf(fp, 
            "    case GMPROP_%s:\n"
            "        return &m_o%s;\n",
            rstProp.m_strID.c_str(),
            rstProp.m_strID.c_str());
    }

    fprintf(fp, 
        "    default:\n"
        "        return NULL;\n"
        "    }\n"
        "}\n\n");

    fclose(fp);
    return true;
}

void CPropCompiler::SetOutputPath(LPCTSTR pszPath)
{
    m_strOutputPath = pszPath;
}

